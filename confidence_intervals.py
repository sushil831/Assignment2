# -*- coding: utf-8 -*-
"""Confidence_Intervals.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14rIKEcxzMQj6BnxUykUi-lnU5pEKcycz
"""

#Q5

import numpy as np
from scipy import stats
from scipy.stats import norm

#Null hypothesis (H0): Mozilla Firefox's market share is 5% or more (P >= 0.05)
#Alternative hypothesis (H1): Mozilla Firefox's market share is less than 5% (P < 0.05)

z_scores=(0.046-0.05)/(np.sqrt((0.05*(1-0.05))/2000))
z_scores

p_value=1-stats.norm.cdf(abs(z_scores))
p_value

#II WebSideStory claims that its sample includes all the daily Internet users. If thatâ€™s the case, then can Microsoft conclude that Mozilla has a less than 5% share of the market?
# we have data on the entire population and the sample value accurately reflects the population number. Thus we can conclude that the share is less than 5%

#Q2
# Population
population = "All readers of PC Magazine in 2004 who rated electronic products on a scale from 1 to 10"
print("A. The population:", population)

# Parameter of Interest
parameter_of_interest = 7.5  # The average rating assigned to a Kodak compact digital camera
print("B. The parameter of interest:", parameter_of_interest)

# Sampling Frame
sampling_frame = "Readers who participated in the survey"
print("C. The sampling frame:", sampling_frame)

# Sample Size
sample_size = 225
print("D. The sample size:", sample_size)

# Sampling Design (This part may require additional information)
sampling_design = "Not specified in the given information"
print("E. The sampling design:", sampling_design)

#F: Any potential sources of bias or the survey or sample other problems with
#VOLUNTARY RESPONSE BIAS: SINCE THE READERS VOLUNTARILY CHOSE TO PARTICIPATE IN THE SURVEY, THIS CAN INTRODUCE VOLUNTARY RESPONSE BIAS. PEOPLE WHO HAD STRONG OPINIONS

#Q6
import scipy.stats as stats

# Given values
sample_mean = 250
margin_of_error = 45
confidence_level = 0.95

# Calculate the standard error of the mean
standard_error = margin_of_error / stats.norm.ppf((1 + confidence_level) / 2)

# Calculate the lower and upper bounds of the confidence interval
lower_bound = sample_mean - standard_error
upper_bound = sample_mean + standard_error

# Interpretation
interpretation = f"The 95% confidence interval ({lower_bound} to {upper_bound} books) suggests that we are 95% confident that the true size of the shipment falls within this range."

print(interpretation)

#Q7
import scipy.stats as stats

# Given values
confidence_level = 0.95
sample_size = 100  # You can change this to your specific sample size
sample_standard_deviation = 10  # You can change this to your specific sample standard deviation

# Calculate the z-interval length
z_critical = stats.norm.ppf((1 + confidence_level) / 2)
z_interval_length = 2 * z_critical * (sample_standard_deviation / (sample_size**0.5))

# Calculate the t-interval length
t_critical = stats.t.ppf((1 + confidence_level) / 2, df=sample_size - 1)
t_interval_length = 2 * t_critical * (sample_standard_deviation / (sample_size**0.5))

# Compare the lengths
shorter_interval = "z-interval" if z_interval_length < t_interval_length else "t-interval"

print(f"The shorter interval is the {shorter_interval}.")

#Q8
import math

def calculate_sample_size(margin_of_error, confidence_level):
    z_critical = stats.norm.ppf(1 - (1 - confidence_level) / 2)
    estimated_proportion = 0.5  # Using 0.5 for maximum variability when the true proportion is unknown
    required_sample_size = (z_critical**2 * estimated_proportion * (1 - estimated_proportion)) / margin_of_error**2
    return math.ceil(required_sample_size)  # Rounding up to ensure a whole number of samples

# Given values
margin_of_error = 0.04  # 4% margin of error
confidence_level = 0.95  # 95% confidence level

# Calculate the minimum required sample size
required_sample = calculate_sample_size(margin_of_error, confidence_level)
print(f"The minimum required sample size is: {required_sample}")

#Q9
import math

def calculate_sample_size(margin_of_error, confidence_level):
    z_critical = stats.norm.ppf(1 - (1 - confidence_level) / 2)
    estimated_proportion = 0.5  # Using 0.5 for maximum variability when the true proportion is unknown
    required_sample_size = (z_critical**2 * estimated_proportion * (1 - estimated_proportion)) / margin_of_error**2
    return math.ceil(required_sample_size)  # Rounding up to ensure a whole number of samples

# Given values
margin_of_error = 0.04  # 4% margin of error
confidence_level = 0.98  # 98% confidence level

# Calculate the minimum required sample size
required_sample = calculate_sample_size(margin_of_error, confidence_level)
print(f"The minimum required sample size for a 98% confidence level is: {required_sample}")

